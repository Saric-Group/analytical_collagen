/* Only global Emin */
// fib.mol.readAtoms(filePaths.inputpath);
// cout << "\nlayers: " << fib.layers;
// cout << "\ndistanceAtoms: " << fib.mol.distanceAtoms;
// cout << "\natoms: " << fib.mol.numAtoms << "\n";
// cout << "\nCD cutoff: " << parameters.cd_cutoff;
// fib.minimizeEnergy();
// cout << "\nMinimal energy configuration:";
// cout << "\nEnergy: " << fib.energy;
// cout << "\nLateral gap: " << fib.latGap;
// cout << "\nRadial gap: " << fib.radGap;
// cout << "\nOffset: " << fib.offset;
// fib.singleEmin();

int nativeN = 1054;
int nativePos = 86;
int nativeNeg = 82;
int pos, neg;
int error = 0;
int samples = 100;
double energy = 0.0;
double gap = 0.0;
double offset = 0.0;

vector<double> vec;
FILE *outf;
outf = fopen(filePaths.outputpath.c_str(), "a");
fprintf(outf, "#radGap\toffset\tenergy");
for (int i = 0; i < samples; i++) {
  cout << "\nMinimizing " << i + 1 << ". random distribution finished with";
  vec = createRandomChargeDistribution(nativeN, nativePos, nativeNeg);
  countCharges(vec, pos, neg);
  if (pos != nativePos || neg != nativeNeg) {
    error++;
  }
  fib.mol.readAtoms(vec);
  fib.energy = 1e16;
  fib.minimizeEnergy();
  fprintf(outf, "\n%.4f", fib.radGap);
  fprintf(outf, "\t%.4f", fib.offset);
  fprintf(outf, "\t%.4f", fib.energy);
  energy += fib.energy;
  gap += fib.radGap;
  offset += fib.offset;
  cout << " min_energy = " << fib.energy << ".";
  if (isinf(fib.energy)) {
    fib.writeXYZ();
  }
}

fprintf(outf, "\n\n");
fprintf(outf, "#Averages:");
fprintf(outf, "\n%.4f", gap / samples);
fprintf(outf, "\t%.4f", offset / samples);
fprintf(outf, "\t%.4f", energy / samples);
fclose(outf);
cout << "\n\nErrors: " << error;
